#include <stdbool.h>



int* find_next(int**im_bw, int**prev_points, const int h, const int w, int step){
    int* init_guess = malloc(2 * sizeof(int));
    int* dir = malloc(2 * sizeof(int));

    int* points_arr = malloc(2*sizeof(int)+sizeof(prev_points));
    points_arr[0] = prev_points[0];
    points_arr[1] = prev_points[0];

    int prev_len = sizeof(points_arr)/sizeof(points_arr[0]);

    dir[0] = ((points_arr[prev_len-3]*1+points_arr[prev_len-2]*2+points_arr[prev_len-1]*3)/6) - points_arr[prev_len-2];
    dir[1] = 3 * (prev_len-2);
    float gradient = dir[0]/3;

    if (gradient>2)
    {
        dir[0] = 0
    }
    
    init_guess[0] = points_arr[prev_len-1] + dir[0];
    init_guess[1] = dir[1];

    int edge_found = 0;
    while (!edge_found) {
        if (init_guess[0] + 1 < h) {
            if ((im_bw[init_guess[0]][init_guess[1]] + im_bw[init_guess[0]-1][init_guess[1]]) == 1) {
                edge_found = 1;
                }
            else if ((im_bw[init_guess[0]][init_guess[1]] + im_bw[init_guess[0]-1][init_guess[1]]) == 0)
            {
                init_guess[0] ++;
            }
            else{
                init_guess[0] --;
            }
            }

        else{
            return h;
        }

    }
    return init_guess[0];
}

int** hor_tracer(int** sub_im, int step, int h, int w){
    step = 5;
    
    bool ground_found = false;
    int i = 0;

    int col = 0;
    int area = 0;

    /* find first point*/
    while (ground_found==false && i < (h-5) && col < (w-5))
    {
        if (sub_im[i,col] != 0){
           area = 0; 
           for (int j = 0; j < 5; i++)
           {
            for (int k = 0; k < 5; k++)
            {
                area = area + sub_im[i+j,k];
            }
            
            
           }
           if (area>20)
            {
                ground_found = true;
            }
            
           
        }
        i++;
        if (i==h-5)
        {
            i = 0;
            col++;
        }
    }
    int start_row = i;

    bool edge_dir_found = false;
    int** hor_points_y[sizeof(int)*w/step];
    // int** dirs[sizeof(int)*w/step];

    i = 0;
    // bool end = false;
    for (int index = 1; index < w/step; index++)  
    {
        int next_y  = find_next(sub_im, hor_points_y, h,w,step);

        hor_points_y[index] = next_y;
        // dirs[index]
        
    }
    return hor_points_y;
        
    }
    
int mom_changes(int** hor_points_y, float thr, int step){
    // f''(x) â‰ˆ [f(x+h) - 2f(x) + f(x-h)] / h^2
    int count = 0;
    for (int i = 1; i < sizeof(hor_points_y)/sizeof(int)-1; i++)
    {
        float fdd = (hor_points_y[i-1] - (hor_points_y[i])*2 + hor_points_y[i+1])/(step*step);
        if (fdd>thr)
        {
            count++;
        }   
    }   
}

// first get y values of horizon with hor_tracer,
// find number of momentum changes with mom_changes, input is hor_points_y
// threshold of 0.5 works well
// standard step is 3
// 
